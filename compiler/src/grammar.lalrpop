use crate::ast;
use crate::identifier;

grammar(filename: ast::SourceFileName);

Identifier: identifier::Identifier = {
    r"\p{ID_Start}\p{ID_Continue}*" => identifier::Identifier::parse(<>)
}

ImportPath: identifier::FQName = {
    <l:ImportPath> "::" <r:Identifier> => l.with_part(r),
    <id:Identifier> => identifier::FQName::from_identifier(id)
}

Import: ast::Import = {
    <start:@L> "import" <path:ImportPath> ";" <end:@R> => ast::Import { 
        path, 
        alias: None,
        position: ast::SourceSpan::new(filename, start, end)
    },
    <start:@L> "import" <path:ImportPath> "as" <alias:Identifier> ";" <end:@R> => ast::Import { 
        path, 
        alias: Some(alias),
        position: ast::SourceSpan::new(filename, start, end)
    }
}

Visibility: ast::Visibility = {
    <e:(<"export">)?> => if e.is_some() { ast::Visibility::Export } else { ast::Visibility::Internal },
}

StructDeclaration: ast::Struct = {
    <start:@L> <visibility:Visibility> "struct" <name:Identifier> "{" "}" <end:@R> => ast::Struct {
        name,
        fields: vec![],
        visibility,
        position: ast::SourceSpan::new(filename, start, end)
    }
}

Type: ast::TypeDescription = {
    "(" ")" => ast::TypeDescription::Named(identifier::Identifier::parse("()")),
    <name:Identifier> => ast::TypeDescription::Named(name),
    <inner:Type> "[]" => ast::TypeDescription::Array(Box::new(inner)),
}

FunctionArgument: ast::Argument = {
    <start:@L> <name:Identifier> ":" <type_:Type> <end:@R> => ast::Argument {
        name,
        type_,
        position: ast::SourceSpan::new(filename, start, end)
    }
}

FunctionArguments: Vec<ast::Argument> = {
    <mut l:FunctionArguments> "," <r:FunctionArgument> => {
        l.push(r);

        l
    }, 
    <l:FunctionArgument> => vec![l]
}

Expressions: Vec<ast::Expression> = {
    <mut l:Expressions> "," <r:Expression> => {
        l.push(r);

        l
    },
    <l:Expression> => vec![l]
}

Literal: ast::Literal = {
    <start:@L> <lit:r#""(?:\\"|.)*""#> <end:@R> => ast::Literal::String(lit[1..lit.len()-1].to_string(), ast::SourceSpan::new(filename, start, end)),
    r#"[1-9][0-9]*"# => ast::Literal::UnsignedInteger(<>.parse().unwrap()),
}

Expression: ast::Expression = {
    <start:@L> <literal:Literal> <end:@R> => ast::Expression {
        position: ast::SourceSpan::new(filename, start, end),
        kind: ast::ExpressionKind::Literal(literal)
    },
    <start:@L> <variable:Identifier> <end:@R> => ast::Expression {
        position: ast::SourceSpan::new(filename, start, end),
        kind: ast::ExpressionKind::VariableReference(variable)
    },
    <start:@L> <target:Expression> "(" <arguments:Expressions?> ")" <end:@R> => ast::Expression {
        position: ast::SourceSpan::new(filename, start, end),
        kind: ast::ExpressionKind::Call{target: Box::new(target), arguments: arguments.unwrap_or_default() }
    },
    <start:@L> <target:Expression> "{" "}" <end:@R> => ast::Expression {
        position: ast::SourceSpan::new(filename, start, end),
        kind: ast::ExpressionKind::StructConstructor(Box::new(target))
    },
    <start:@L> <target:Expression> "." <field_name:Identifier> <end:@R> => ast::Expression {
        position: ast::SourceSpan::new(filename, start, end),
        kind: ast::ExpressionKind::FieldAccess {
            target: Box::new(target), field_name
        }
    }
}

Statement: ast::Statement = {
    "let" <name:Identifier> ":" <type_:Type> "=" <expression:Expression> ";" => ast::Statement::Let(name, type_, expression),
    <start:@L> "return" <expression:Expression> ";" <end:@R> => ast::Statement::Return(expression, ast::SourceSpan::new(filename, start, end)),
    <start:@L> <expression:Expression> ";" <end:@R> => ast::Statement::Expression(expression, ast::SourceSpan::new(filename, start, end))
}

FunctionBody: ast::FunctionBody = {
    <start:@L> "{" <statements:(<Statement>)*> "}" <end:@R> => {
        ast::FunctionBody::Statements(statements, ast::SourceSpan::new(filename, start,end))
    }, 
    <start:@L> "extern" "(" <name:Identifier> ")" ";" <end:@R> => {
        ast::FunctionBody::Extern(name, ast::SourceSpan::new(filename, start, end))
    }
}

Function: ast::Function = {
    <start:@L> <visibility:Visibility> "fn" <name:Identifier> "(" <arguments:FunctionArguments?> ")" ":" <return_type:Type>
        <body:FunctionBody> <end:@R>
        => ast::Function {
            visibility,
            name,
            arguments: arguments.unwrap_or_default(),
            return_type,
            body,
            position: ast::SourceSpan::new(filename, start, end)
        }
}

ImplDeclaration: ast::Impl = {
    "impl" <struct_name:Identifier> "{" <functions:(<Function>)*> "}" => ast::Impl {
        struct_name,
        functions
    }
}

Declaration: ast::Declaration = {
    <start:@L> <s:StructDeclaration> <end:@R> => ast::Declaration {
        kind: ast::DeclarationKind::Struct(s),
        position: ast::SourceSpan::new(filename, start, end)
    },
    <start:@L> <impl_:ImplDeclaration> <end:@R> => ast::Declaration {
        kind: ast::DeclarationKind::Impl(impl_),
        position: ast::SourceSpan::new(filename, start, end)
    },
    <start:@L> <function:Function> <end:@R> => ast::Declaration {
        kind: ast::DeclarationKind::Function(function),
        position: ast::SourceSpan::new(filename, start, end)
    }
}

pub SourceFile: ast::SourceFile = {
    <imports:(<Import>)*> <declarations:(<Declaration>)*> => ast::SourceFile {
        imports,
        declarations,
        name: filename
    }
}
